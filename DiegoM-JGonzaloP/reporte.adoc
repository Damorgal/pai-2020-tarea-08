= Tarea 08
:toc:

== Implementación 

=== Pregunta 01
Implementación del heap-montículo ternario:
Parte asiganada a Diego, se implementa una primera versión y José revisa y pone test al programa.

La estuctura contiene los siguientes datos:

 * vec      : [int]    -- colección de enteros
 * size     : int      -- tamaño actual del vector
 * capacity : int      -- capacidad total de memoria para el vector

Inicializar la estructura THeap como THeap *h = NULL; y después 
agregar un elemento cualquiera.

=== Pregunta 02
Complejidad O(log_3(n)): (n = size = tamaño actual del arreglo)

Se accede trivialmente al máximo. Para el insert, se coloca el
nuevo elemento en O(1) y se realiza el heapify que en el peor 
caso es hasta el principio, el cual está a distancia log_3(n).
Similarmente para el remove, se reemplaza el máximo por el 
último en el arreglo en O(1) y se realiza otro heapify hacia
abajo que de igual manera, el peor caso se alcanza en log_3(n).

Comparación con montículo binario:
A priori, se supera la complejidad respecto al binario debido a 
que se necesitan menos pasos para realizar el heapify. Es una 
ventaja contar con menos niveles de profundidad por lo anterior.
Sin embargo, se ocupa más memoria para tener niveles profundos 
en el árbol.

== Aplicación 

=== Pregunta 03
Aplicación para mónticulos: Cálculo de la mediana en streaming.
Parte asiganada a José, se implementa una primera versión y Diego revisa y pone test al programa.
La siguiente aplicación tiene las siguientes dependencias:

"heap.c" -> se implementa la estructura de montículo ternario
"reverseheap.c" -> modificación de las funciones en heap.c

El cálculo de el valor mediano toma como entrada 2 montículos:
thmin y thmax, la variable de la mediana "median" está definida
como global.

=== Pregunta 04
El montículo thmax guarda la mitad inferior de los datos obtenidos,
Por otro lado, el montículo thmin almacena la mitad superior de los 
datos.

Por la forma en la que se implementó, se puede decir que,  
la raíz de thmax guarda el valor más grande de los pequeños 
y la raíz de thmin guarda el valor más pequeño de los grandes.
 
Si alguno de los dos montículos es más grande que el otro, 
la mediana se encontrará en la raíz del de mayor tamaño.
Caso contrario, la mediana será el valor promedio entre las dos
raíces.

=== Pregunta 05
Análisis de complejidad:

En el peor de los casos, se debe remover la raíz de uno de los 
montículos para colocarlo sobre el otro, y se debe agregar el 
dato de entrada en el montículo con menos elementos.
 
Suponiendo que el tamaño de thmax es mayor al de thmin,
y el dato es menor a la mediana actual, se debe colocar el valor
máximo de thmax en thmin, para ello, se utilizan las funciones de
remover e insertar.

La acción de remover el valor máximo de thmax, en el peor caso,
deberá realizar la función heapify en T(n) = log_3(n). 
(recordar que el último dato del arreglo se intercambia por el primero
y a partir de ahi, se trata de encontrar el lugar para este elemento).

El nuevo valor insertado en thmin tendrá que estar en la raíz,
la cual se encuentra a una distacia  de log_3(n). La función heapify 
tiene un tiempo de ejecución de T(n) =  log_3(n).

Se deberá incluír el nuevo dato de entrada en el montículo de menor
tamaño (en este caso thmax), por lo que, si este corresponde a la raíz,
se encontrará a una distancia de log_3(n), de igual manera T(n) = log_3(n).

Las operaciones para la asignación de variables auxiliares y la modificación
de el valor mediano, se realizan en tiempo constante (T(n) = c).

En total, el tiempo de ejecución de este algoritmo es:

T(n) = 3log_{3}(n) + c
 
Por lo que:

T(n) = O(log(n)).
